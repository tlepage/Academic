__author__ = 'tomlepage'
# A one-dimensional cellular automata takes in a string, which in our
# case, consists of the characters '.' and 'x', and changes it according
# to some predetermined rules. The rules consider three characters, which
# are a character at position k and its two neighbours, and determine
# what the character at the corresponding position k will be in the new
# string.

# For example, if the character at position k in the string  is '.' and
# its neighbours are '.' and 'x', then the pattern is '..x'. We look up
# '..x' in the table below. In the table, '..x' corresponds to 'x' which
# means that in the new string, 'x' will be at position k.

# Rules:
#          pattern in         position k in        contribution to
# Value    current string     new string           pattern number
#                                                  is 0 if replaced by '.'
#                                                  and value if replaced
#                                                  by 'x'
#   1       '...'               '.'                        1 * 0
#   2       '..x'               'x'                        2 * 1
#   4       '.x.'               'x'                        4 * 1
#   8       '.xx'               'x'                        8 * 1
#  16       'x..'               '.'                       16 * 0
#  32       'x.x'               '.'                       32 * 0
#  64       'xx.'               '.'                       64 * 0
# 128       'xxx'               'x'                      128 * 1
#                                                      ----------
#                                                           142

# To calculate the patterns which will have the central character x, work
# out the values required to sum to the pattern number. For example,
# 32 = 32 so only pattern 32 which is x.x changes the central position to
# an x. All the others have a . in the next line.

# 23 = 16 + 4 + 2 + 1 which means that 'x..', '.x.', '..x' and '...' all
# lead to an 'x' in the next line and the rest have a '.'

# For pattern 142, and starting string
# ...........x...........
# the new strings created will be
# ..........xx...........  (generations = 1)
# .........xx............  (generations = 2)
# ........xx.............  (generations = 3)
# .......xx..............  (generations = 4)
# ......xx...............  (generations = 5)
# .....xx................  (generations = 6)
# ....xx.................  (generations = 7)
# ...xx..................  (generations = 8)
# ..xx...................  (generations = 9)
# .xx....................  (generations = 10)

# Note that the first position of the string is next to the last position
# in the string.

# Define a procedure, cellular_automaton, that takes three inputs:
#     a non-empty string,
#     a pattern number which is an integer between 0 and 255 that
# represents a set of rules, and
#     a positive integer, n, which is the number of generations.
# The procedure should return a string which is the result of
# applying the rules generated by the pattern to the string n times.

def replace_middle_3(char, string):
    new_string = string[0] + char + string[2]

    return new_string

def create_pattern(pnum):
    num = pnum
    patterns = ['xxx', 'xx.', 'x.x', 'x..', '.xx', '.x.', '..x', '...']
    mapping = [128, 64, 32, 16, 8, 4, 2, 1]

    for i in range(0, 8):
        div = num / mapping[i]
        if div != 0:
            num -= mapping[i] * div
            patterns[i] = replace_middle_3('x', patterns[i])
        else:
            patterns[i] = replace_middle_3('.', patterns[i])
        i += 1

    new_pattern = patterns[::-1]

    return new_pattern

def build_string_from_index(l, m, r):
    string = l + m + r

    return string

def string_to_list(string):
    lst = []
    for e in string:
        lst.append(e)

    return lst

def list_to_string(lst):
    string = ''
    for e in lst:
        string = string + e

    return string

def create_neighbors(length):
    neighbors = []
    for i in range(0, length):
        if i == 0:
            neighbors.append([length - 1, 1])
        elif i == length - 1:
            neighbors.append([i - 1, 0])
        else:
            neighbors.append([i - 1, i + 1])

    return neighbors

def copy_list(list1, list2):
    for i in range(0, len(list1)):
        list2[i] = list1[i]

def cellular_automaton(string, pnum, generations):
    if len(string) == 1 and generations == 1:
        return 'x'
    elif len(string) == 1 and generations == 2:
        return '.'

    neighbors = create_neighbors(len(string))
    org_pattern = ['...', '..x', '.x.', '.xx', 'x..', 'x.x', 'xx.', 'xxx']
    pattern = create_pattern(pnum)

    #print string
    #print org_pattern
    #print pattern

    #print 'neighbors'
    #print neighbors
    lstring = string_to_list(string)
    modified_string = string_to_list(string)
    # go through generation count
    for i in range(0, generations):
        copy_list(modified_string, lstring)
        # for each index
        for j in range(0, len(string)):
            pstring = build_string_from_index(lstring[neighbors[j][0]], lstring[j], lstring[neighbors[j][1]])
            #print 'pstring: ' + pstring
            #print 'neighbors: ' + lstring[neighbors[j][0]] + lstring[j] + lstring[neighbors[j][1]]
            if pstring in org_pattern:
                idx = org_pattern.index(pstring)
                #print idx
                nstring = pattern[idx]
                modified_string[j] = nstring[1]
                #print lstring

    new_string = list_to_string(modified_string)

    return new_string

print cellular_automaton('.x.x.x.x.', 17, 2)
#>>> xxxxxxx..
print cellular_automaton('.x.x.x.x.', 249, 3)
#>>> .x..x.x.x
print cellular_automaton('...x....', 125, 1)
#>>> xx.xxxxx
print cellular_automaton('...x....', 125, 2)
#>>> .xxx....
print cellular_automaton('...x....', 125, 3)
#>>> .x.xxxxx
print cellular_automaton('...x....', 125, 4)
#>>> xxxx...x
print cellular_automaton('...x....', 125, 5)
#>>> ...xxx.x
print cellular_automaton('...x....', 125, 6)
#>>> xx.x.xxx
print cellular_automaton('...x....', 125, 7)
#>>> .xxxxx..
print cellular_automaton('...x....', 125, 8)
#>>> .x...xxx
print cellular_automaton('...x....', 125, 9)
#>>> xxxx.x.x
print cellular_automaton('...x....', 125, 10)
#>>> ...xxxxx

